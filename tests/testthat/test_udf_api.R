# Automatically generated by openapi-generator (https://openapi-generator.tech)
# Please update as you see appropriate

context("Test UdfApi")

api.instance <- UdfApi$new()

test_that("DeleteUDFInfo", {
  # tests for DeleteUDFInfo
  # base path: http://localhost/v1
  # delete a registerd UDF, this will remove all sharing and can not be undone
  # @param namespace character namespace array is in (an organization name or user's username)
  # @param name character name to register udf under
  # @return [Void]

  # uncomment below to test the operation
  #expect_equal(result, "EXPECTED_RESULT")
})

test_that("GetUDFInfo", {
  # tests for GetUDFInfo
  # base path: http://localhost/v1
  # get a specific UDF in the given namespace
  # @param namespace character namespace array is in (an organization name or user's username)
  # @param name character name to register udf under
  # @return [UDFInfo]

  # uncomment below to test the operation
  #expect_equal(result, "EXPECTED_RESULT")
})

test_that("GetUDFInfoSharingPolicies", {
  # tests for GetUDFInfoSharingPolicies
  # base path: http://localhost/v1
  # Get all sharing details of the udf
  # @param namespace character namespace array is in (an organization name or user's username)
  # @param name character name of UDFInfo
  # @return [array[UDFSharing]]

  # uncomment below to test the operation
  #expect_equal(result, "EXPECTED_RESULT")
})

test_that("RegisterUDFInfo", {
  # tests for RegisterUDFInfo
  # base path: http://localhost/v1
  # register a UDF in the given namespace
  # @param namespace character namespace array is in (an organization name or user's username)
  # @param name character name to register udf under
  # @param udf UDFInfoUpdate udf to register
  # @return [Void]

  # uncomment below to test the operation
  #expect_equal(result, "EXPECTED_RESULT")
})

test_that("ShareUDFInfo", {
  # tests for ShareUDFInfo
  # base path: http://localhost/v1
  # Share a UDF with a user
  # @param namespace character namespace array is in (an organization name or user's username)
  # @param name character name of UDFInfo
  # @param udf.sharing UDFSharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace, if permissions already exist they will be deleted then new ones added. In the event of a failure, the new polcies will be rolled back to prevent partial policies, and its likely the udf will not be shared with the namespace at all
  # @return [Void]

  # uncomment below to test the operation
  #expect_equal(result, "EXPECTED_RESULT")
})

test_that("SubmitGenericUDF", {
  # tests for SubmitGenericUDF
  # base path: http://localhost/v1
  # submit a generic UDF in the given namespace
  # @param namespace character namespace array is in (an organization name or user's username)
  # @param udf GenericUDF udf to run
  # @param accept.encoding character Encoding to use (optional)
  # @return [data.frame]

  # uncomment below to test the operation
  #expect_equal(result, "EXPECTED_RESULT")
})

test_that("SubmitMultiArrayUDF", {
  # tests for SubmitMultiArrayUDF
  # base path: http://localhost/v1
  # submit a multi-array UDF in the given namespace
  # @param namespace character namespace array is in (an organization name or user's username)
  # @param udf MultiArrayUDF udf to run
  # @param accept.encoding character Encoding to use (optional)
  # @return [data.frame]

  # uncomment below to test the operation
  #expect_equal(result, "EXPECTED_RESULT")
})

test_that("SubmitUDF", {
  # tests for SubmitUDF
  # base path: http://localhost/v1
  # send a UDF to run against a specified array/URI registered to a group/project
  # @param namespace character namespace array is in (an organization name or user's username)
  # @param array character name/uri of array that is url-encoded
  # @param udf MultiArrayUDF udf to run
  # @param x.payer character Name of organization or user who should be charged for this request (optional)
  # @param accept.encoding character Encoding to use (optional)
  # @param v2 character flag to indicate if v2 array udfs should be used, currently in beta testing. Setting any value will enable v2 array udfs (optional)
  # @return [data.frame]

  # uncomment below to test the operation
  #expect_equal(result, "EXPECTED_RESULT")
})

test_that("UdfNamespaceArrayEndTimestampsGet", {
  # tests for UdfNamespaceArrayEndTimestampsGet
  # base path: http://localhost/v1
  # retrieve a list of timestamps from the array fragment info listing in milliseconds, paginated
  # @param namespace character namespace array is in (an organization name or user's username)
  # @param array character name/uri of array that is url-encoded
  # @param page integer pagination offset (optional)
  # @param per.page integer pagination limit (optional)
  # @return [ArrayEndTimestampData]

  # uncomment below to test the operation
  #expect_equal(result, "EXPECTED_RESULT")
})

test_that("UpdateUDFInfo", {
  # tests for UpdateUDFInfo
  # base path: http://localhost/v1
  # updated an existing registerd UDF in the given namespace
  # @param namespace character namespace array is in (an organization name or user's username)
  # @param name character name to register udf under
  # @param udf UDFInfoUpdate udf to update
  # @return [Void]

  # uncomment below to test the operation
  #expect_equal(result, "EXPECTED_RESULT")
})

